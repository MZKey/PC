# Инспекция кода

Инспекция кода (ревизия кода, рецензия кода, Code review) – это систематическая проверка исходного кода программы. Цель проверки – обнаружение и исправление ошибок, которые были пропущены, остались незамечены при разработке. Результат инспекции как правило – улучшение качество ПО и навыки разработчика.

В ходе инспекции, когда могут быть найдены, с последующим устранением, такие уязвимости, как ошибки в форматировании строк, утечка памяти, переполнение буфера, что улучшает безопасность ПО. Системы контроля версий также дают возможность проведения совместной инспекции исходного кода. Помимо этого, есть инструменты, которые предназначены именно для совместной инспекции.

##### Существует множество примеров, когда совместная инспекция кода улучшила программный проект:

- Blender — пакет для создания трёхмерной компьютерной графики, значительно улучшенный open-source сообществом;
- Ядро Linux, разработка которого была начата финским студентом Линусом Торвальдсом.



## На что следует обратить внимание.

#### Архитектура/Дизайн.

- Принцип «одной ответственности».

  Идея в том, что у каждого класса должно быть только одно назначение. На самом деле реализовать это труднее, чем кажется. Я обычно применяю это правило и к методам. Если возникает нужда в союзе «и» при описании того, что делает метод, то это знак, что стоит разделить его на несколько более простых.

- Дупликация кода.

  Если один и тот же кусок используется три раза или больше, то необходимо вынести его в отдельный метод.

- Принцип «Открыт/Закрыт».

  Если язык объектно-ориентированный, то открыты ли ваши объекты для расширения, но закрыты для модификации? Что произойдет, если нам нужно будет добавить еще один экземпляр класса?

- При изменении кода всегда пытайтесь его улучшить.

- Обработка ошибок.

- Эффективность.

  #### Стиль.

- Имена методов.

  Давать имена различным вещам — одна из самых сложных задач в программировании. Если метод называется `get_message_queue_name()`, но делает что-то кроме этого, например, убирает HTML из входных данных, тогда это имя не подходит ему.

- Документация.

  Сложные методы лучше задокументировать так, чтобы было понятно, за что отвечает каждый аргумент.

- Длина классов.

  Классы должны быть меньше 300 строк, а в идеале — меньше 100. Скорее всего, если в вашем коде есть длинные классы, то их можно разбить на несколько, что облегчит понимание их предназначения.

- Длина файла. 

  Для Python 1000 строк в одном файле — предел. Если их становится больше, то, возможно, стоит разбить файл на несколько, с более специфичным предназначением. Чем больше файл, тем меньше читабельность кода в нем.

  #### Тестирование.

- Полнота тестов.

  Мне нравится, когда нововведения тестируются. Но насколько эти тесты продуманы? Могут ли они заставить ваш код упасть? Легко ли они читаются? Насколько они хрупки? Насколько они большие? Медленные ли они?

- Тестирование на правильном уровне.  

  Тестируется ли тот уровень приложения, который нужно тестировать для проверки функциональности? Гарри Бернардт рекомендует такое соотношение — 95% юнит-тестов и 5% интеграционных тестов.

- Соответствование требованиям. 

  Обычно в конце инспектирования я смотрю на задачу или баг, для которого был предназначен тест. Если он не соответствует каким-то критериям, то лучше провести тестирование заново.

  

## Проинспектируйте свой код сами.

Перед совершением коммита просмотрите свой код на следующие вещи:

- Оставили ли вы какие-нибудь комментарии или TODO?
- Говорят ли сами за себя имена переменных?

- и т.д.

Я хочу быть уверенным в том, что код пройдет мое собственное инспектирование перед тем, как его будут оценивать другие люди, чтобы не создавать им лишней работы.



## Как проводить инспектирование кода.

Человеческий фактор при инспектировании порой приносит не меньше проблем, чем само инспектирование.

Несколько приемов для проведения таких мероприятий:

- Задавайте вопросы. 

  Задавайте вопросы, которые подтолкнут разработчиков к обсуждению. Например, как работает этот метод? Если изменится какое-то требование, то что нужно будет поменять в коде? Как сделать код более поддерживаемым?

- Обсуждайте детали наедине. 

  Большие архитектурные изменения лучше обсуждать всей командой, в то время как про мелкие детали лучше говорить наедине с разработчиком, который ответственен за них, дабы не вовлекать лишних людей.

- Дело в коде.

   Обсуждайте сам код, а не разработчиков, которые его писали. Это создаcт непринужденную атмосферу, тем более, программисты ни при чем — инспектирование призвано улучшить качество кода.

- Объясняйте причины.

  Всегда лучше рассказать или спросить, почему предложенные изменения необходимы. Порой может возникнуть чувство, что они несущественны, до тех пор, пока вы не объясните повод.


## Контролируем качество кода с помощью платформы SonarQube

SonarQube — это платформа с открытым исходным кодом, предназначенная для непрерывного анализа и измерения качества кода. SonarQube предоставляет следующие возможности:

- Поддержка языков Java, C, C++, C#, Objective-C, Swift, PHP, JavaScript, Python и др.
- Предоставляет отчеты о дублировании кода, соблюдении стандартов кодирования, покрытия кода модульными тестами, возможные ошибки в коде, плотность комментариев в коде, технический долг и другое.
- Сохраняет историю метрик и строит графики изменения этих метрик во времени.
- Обеспечивает полностью автоматизированный анализ: интегрируется с Maven, Ant, Gradle и распространенными системами непрерывной интеграции.
- Позволяет интегрироваться с такими IDE, как Visual Studio, IntelliJ IDEA и Eclipse с помощью плагина SonarLint.
- Обеспечивает интеграцию с внешними инструментами: JIRA, Mantis, LDAP, Fortify и т.д.
- Можно расширять существующую функциональность с помощью сторонних плагинов.
- Реализует методологию SQALE для оценки технического долга.

На главной странице SonarQube вы видите список проектов, добавленных в систему, с краткой статистикой по каждому проекту: версия сборки, количество строк кода, количество багов, уязвимостей и признаков «кода с душком», дата последнего анализа:

![img](https://habrastorage.org/getpro/habr/post_images/4ea/763/25a/4ea76325ae0accbd481b632e5bdb8c26.png)

Для получения более детальной информации о состоянии проекта перейдем на страницу метрик проекта:

![img](https://habrastorage.org/getpro/habr/post_images/221/0a2/150/2210a215052586f9864017951fa29fdd.png)

Здесь представлена информация о следующих метриках кода: Reliability (Надежность), Security (Безопасность), Maintainability (Поддерживаемость), Coverage (Покрытие тестами), Duplications (Дублирование), Size (Размер кодовой базы), Complexity (Цикломатическая сложность), Documentation (Документирование кода) и Issues (Ошибки).

Перейдя к метрике Reliability, мы получаем информацию об общем количестве обнаруженных багов и новые баги, обнаруженные во время последнего анализа, рейтинг надежности кода по шкале от A до E, где E — наихудший рейтинг, свидетельствующий о том, что был найден по крайней мере один blocker баг, а также время, необходимое на устранение всех найденных ошибок:

![img](https://habrastorage.org/getpro/habr/post_images/999/190/03d/99919003d36420fd51b4be20e675d7ed.png)

Платформа SonarQube позволяет анализировать метрики кода сверху вниз, от уровня проекта в целом до отдельных модулей и файлов. Так, например, если вы кликните на рейтинг надежности (Reliability Rating), вы увидите список файлов проекта, отсортированных по возрастанию рейтинга надежности. Это позволит сфокусироваться на наиболее проблемных участках кода:

![img](https://habrastorage.org/getpro/habr/post_images/af2/a66/870/af2a6687078538df2d49d4f9b14ff651.png)

Затем вы можете перейти к файлу с исходным кодом и к конкретным участкам кода, в которых обнаружены ошибки:

![img](https://habrastorage.org/getpro/habr/post_images/955/f98/85c/955f9885c53a7a3135d06acca526fe60.png)

Такая навигация сверху вниз доступна и для других метрик.

На странице метрики Security доступна информация об общем количестве уязвимостей, новых уязвимостях, рейтинге безопасности (также по шкале от A до E), и времени, которое потребуется на устранение уязвимостей:

![img](https://habrastorage.org/getpro/habr/post_images/33f/af1/d18/33faf1d18f6e3ff1e040cf71dd6a1fcb.png)

Интеграция с системами контроля версий позволяет также автоматически назначать баги в SonarQube на тех разработчиков, которые их допустили. Также вы можете назначать баги на разработчиков вручную, изменять их тип (bug, vulnerability или code smell), важность, теги, добавлять комментарии. Для большего удобства использования доступна функция массового изменения багов:

![img](https://habrastorage.org/getpro/habr/post_images/a4f/15c/040/a4f15c0404fa3e9c72379ceed767f06a.png)

## Быстрый поиск ошибок и чистый код с SonarLint

Сейчас почти во всех IDE есть линтер — статический анализатор возможных ошибок. Другими словами, он предугадывает ещё до запуска кода, что может пойти не так, и выделяет предполагаемые ошибки.

![img](https://tproger.ru/s3/uploads/2020/05/0_IqQCJIioNJTxagPJ.png)


В свою очередь, *динамический* анализ не предугадывает, а действительно запускает/компилирует части кода, чтобы определить, работает ли он, но делает это автоматически в фоновом режиме. То есть он на самом деле знает, что пойдёт не так в процессе выполнения программы.

SonarLint — это тот самый динамический анализатор кода, который поможет решить следующие проблемы.

### Лишний код

Допустим, вы не удалили закомментированные части кода, оставили неиспользуемые функции и прочие рудименты. SonarLint предупредит об этом, и вы сможете своевременно очистить код от всего лишнего.

### Уязвимости

Большая обновляемая база данных с перечнем уязвимостей позволяет плагину вовремя предупреждать о любых известных уязвимостях, которые встречаются в вашем коде.

### Когнитивная сложность

Если говорить кратко, разработчики плагина создали математическую формулу, которая может оценить, насколько читабелен ваш код.

Это не только полезно, но и просто. Каждый раз, когда SonarLint предупреждает вас о чрезмерной сложности, это сопровождается объяснением правила, которое вы нарушили. Например, «слишком большая вложенность операторов if», более известная как спагетти-код. Удобно, правда?

Плагин SonarLint позволяет использовать лучшие практики и писать понятный чистый код.

## Отличие SonarLint и SonarQube.

SonarLint живет только в IDE (IntelliJ, Eclipse и Visual Studio). Его цель - дать мгновенную обратную связь при вводе кода. Для этого он концентрируется на том, какой код вы добавляете или обновляете.

SonarQube -это центральный сервер, который обрабатывает полный анализ (запускаемый различными сканерами SonarQube). Его цель - дать 360-градусное представление о качестве вашей кодовой базы. Для этого он регулярно анализирует все исходные строки вашего проекта.

И SonarLint, и SonarQube полагаются на одни и те же статические анализаторы исходного кода - большинство из них написаны с использованием технологии SonarSource.



## Инспекции кода с применением инструмента Code Collaborator.

![Мем](https://hsto.org/storage2/f52/9a1/1bd/f529a11bda126484a66b1fcdf65f47cf.png)

Опустим установку и первичную настройку CC, благо она проста и хорошо документирована. Разберем работу с CodeCollaborator на тестовом проекте.

Ситуация: разработчик добавил в проект три файла и отправляет их на инспекцию коллегам, которые находят несколько дефектов. После этого автор исправляет обнаруженные ошибки и отсылает обновления на повторною инспекцию. Его коллеги проверяют корректность исправления дефектов и утверждают эти изменения, разрешая тем самым автору включить изменения в общий репозиторий.

Инспекция создается в несколько кликов. Плагины к Visual Studio или Eclipse направляют нас в окно создания инспекции (оно же — добавления файлов в существующую инспекцию).

![Добавление файлов](https://hsto.org/storage2/6fc/550/f28/6fc550f28aab431262fe107567ae17ba.png)

Добавляем файлы для отправки на инспекцию:

![Добавление файлов](https://hsto.org/storage2/88e/a8f/961/88ea8f9616013c93f73163ecfd8b4fde.png)

СodeСollaborator работает поверх системы контроля версий (в нашем случае это SVN). В программе реализована поддержка большинства распространенных систем контроля версий.
По умолчанию все добавленные и измененные файлы в локальной рабочей копии будут добавлены в инспекцию.
Совет: очень удобно иметь свою рабочую копию для разных задач, например, чтобы добавлять целиком весь список файлов по умолчанию, а не отмечать их галочками по одному.

После этого desktop-клиент автоматически перенаправляет нас на страницу назначения инспекторов, где мы указываем участников инспекции и запускаем сам процесс инспектирования.

![Инспекция](https://hsto.org/storage2/a07/752/a7f/a07752a7f966c895a978ddd017ad072e.png)

Всем участникам инспекции по почте рассылаются уведомления, у всех изменяется значок desktop-клиента в трее. Для удобства desktop-клиент показывает текущие активные инспекции и перенаправляет пользователя на нужную. Кроме того, можно перейти в инспекцию по ссылке из письма-уведомления или выбрать желаемую из списка активных с главной страницы веб-интерфейса. В общем, потеряться сложно.

![Инспекция](https://hsto.org/storage2/72f/94a/d0d/72f94ad0d11f99e6fb19391fcc66475c.png)

Инспектор проверяет код и пишет свою рецензию. Удобная панель навигации по инспекции сильно упрощает эту задачу: реализован переход к следующему (предыдущему) файлу, к следующей (предыдущей) беседе.

Для создания комментария или фиксирования дефекта достаточно просто щелкнуть мышкой в нужную строку кода и написать в появившемся окошке текст комментария, а в случае дефекта — дополнительно указать его важность и тип.

![Инспекция](https://hsto.org/storage2/913/73f/2a3/91373f2a3667e89320894415718848a0.png)
![Инспекция](https://hsto.org/storage2/a3e/872/962/a3e8729629cff637340c6bfb04f637a9.png)

После просмотра всего кода инспектор ставит отметку о завершении процесса инспектирования. Если есть открытые дефекты, то система автоматически переводит инспекцию в режим «Работа над ошибками»; если все дефекты закрыты, то инспекция переводится в состояние «Завершена». Причем инспектор сможет поставить отметку о том, что он закончил инспектирование, — только после прочтения всех комментариев и утверждения всех файлов в инспекции (случайно что-то пропустить сложно).

Автор кода видит, что инспекция переведена в состояние «Работы над ошибками» (Rework), все открытые дефекты сведены в таблицу, напротив каждого файла появились иконки с дефектами и комментариями. Такую же сводку видят все участники.

![Инспекция](https://hsto.org/storage2/3d7/608/6cc/3d76086cc444b65d1a2eefcfc1e9f01a.png)

Завязавшуюся беседу удобно просматривать.

![Инспекция](https://hsto.org/storage2/a8d/de8/107/a8dde8107d3940144669c38436d7b1e9.png)

Автор проводит работу над ошибками и добавляет измененный код в инспекцию. Процедура добавления кода идентична процедуре при создании инспекции, только вместо новой инспекции указывается существующая; файлы также добавляются по умолчанию.

Voilà! Дальше CodeCollaborator сам разберется — куда и какие изменения внесены. Затем инспекторам снова приходят уведомления о том, что рецензии ждут новые изменения. Удобная навигация позволяет выбрать для сравнения любые версии файла.

Инспекция завершается после закрытия дефектов инспекторами и утверждения всех измененных файлов.

![Инспекция](https://hsto.org/storage2/cb0/1f4/1d8/cb01f41d841677fd842acb296fff279b.png)

Теперь автор может добавить свой код в общий репозиторий. Стандартных отчетов CodeCollaborator вполне достаточно для эффективной работы: инструмент предлагает большое количество фильтров.

Вот пара полезных отчетов. Отчет о затраченном на инспекции времени:

![Инспекция](https://hsto.org/storage2/b10/75c/134/b1075c134f33acbfa4657db21bca39b3.png)

Отчет по дефектам с Severity = Major за период времени:

![Инспекция](https://hsto.org/storage2/995/124/94c/99512494c972aeddad76b9501760e31b.png)

Если сравнивать обмен патчами по почте или просмотр diff'ов в VCS c проведением инспекций при помощи CodeCollaborator, в голову приходит такое сравнение: можно стирать вещи вручную, а можно в стиральной машине. Надо лишь выбрать оптимальный вариант для конкретной ситуации.

Совет: удобно завести для каждой разрабатываемой функциональности отдельную рабочую копию. В итоге нет надобности выбирать нужные файлы, поскольку все измененные файлы в рабочей копии добавляются в инспекцию по умолчанию.


#### Источники:

- https://ru.wikipedia.org/wiki/Просмотр_кода - Википедия
- https://tproger.ru/translations/code-review-best-practices/ - tproger.ru
- https://habr.com/ru/company/pt/blog/150995/ - Инспекции кода с применением инструмента Code Collaborator
- https://habr.com/ru/company/pvs-studio/blog/315422/ - Контролируем качество кода с помощью платформы SonarQube
